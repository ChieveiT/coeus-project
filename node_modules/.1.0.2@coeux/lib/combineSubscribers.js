'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.default = combineSubscribers;

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _forEach = require('lodash/forEach');

var _forEach2 = _interopRequireDefault(_forEach);

var _isEmpty = require('lodash/isEmpty');

var _isEmpty2 = _interopRequireDefault(_isEmpty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function combineSubscribers(subscribers) {
  var keyStack = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

  if (!(0, _isPlainObject2.default)(subscribers)) {
    throw new Error('Invalid subscriber on ' + keyStack.join('.') + '.');
  }

  var subscriberKeys = Object.keys(subscribers);
  var finalSubscriberKeys = [];
  var finalSubscribers = {};

  (0, _forEach2.default)(subscriberKeys, function (key) {
    if (typeof subscribers[key] === 'function') {
      finalSubscriberKeys.push(key);
      finalSubscribers[key] = subscribers[key];
    } else if ((0, _isPlainObject2.default)(subscribers[key])) {
      // support recursive
      finalSubscriberKeys.push(key);
      finalSubscribers[key] = combineSubscribers(subscribers[key], [].concat(_toConsumableArray(keyStack), [key]));
    }
  });

  if ((0, _isEmpty2.default)(finalSubscriberKeys)) {
    throw new Error('Invalid subscriber on ' + keyStack.join('.') + '.');
  }

  // to store the previous state
  var previousStates = {};

  return function combination() {
    var states = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    return new Promise(function (resolve, reject) {
      if (!(0, _isPlainObject2.default)(states)) {
        throw new Error('Expected a plain object on state ' + keyStack.join('.') + ' ' + ('but receive type "' + (typeof states === 'undefined' ? 'undefined' : _typeof(states)) + '".') + 'Try to change subscriber shape to match state shape.');
      }

      var promises = [];

      (0, _forEach2.default)(finalSubscriberKeys, function (key) {
        var subscriber = finalSubscribers[key];

        // only has the sub-state been changed
        // we notify the sub-subscriber
        if (previousStates[key] === states[key]) {
          return;
        }

        if (states[key] === undefined) {
          delete previousStates[key];
        } else {
          previousStates[key] = states[key];
        }

        promises.push(subscriber(states[key]));
      });

      Promise.all(promises).then(function () {
        return resolve();
      }, function (e) {
        return reject(e);
      });
    });
  };
}