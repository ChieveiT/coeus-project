'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports.default = combineReducers;

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _isEmpty = require('lodash/isEmpty');

var _isEmpty2 = _interopRequireDefault(_isEmpty);

var _isEqual = require('lodash/isEqual');

var _isEqual2 = _interopRequireDefault(_isEqual);

var _forEach = require('lodash/forEach');

var _forEach2 = _interopRequireDefault(_forEach);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function combineReducers(reducers) {
  var keyStack = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];

  if (!(0, _isPlainObject2.default)(reducers)) {
    throw new Error('Unexpected type of reducer on ' + keyStack.join('.') + '.');
  }

  var reducerKeys = Object.keys(reducers);
  var finalReducerKeys = [];
  var finalReducers = {};

  (0, _forEach2.default)(reducerKeys, function (key) {
    if (typeof reducers[key] === 'function') {
      finalReducerKeys.push(key);
      finalReducers[key] = reducers[key];
    } else if ((0, _isPlainObject2.default)(reducers[key])) {
      // recursive
      finalReducerKeys.push(key);
      finalReducers[key] = combineReducers(reducers[key], [].concat(_toConsumableArray(keyStack), [key]));
    }
  });

  if ((0, _isEmpty2.default)(finalReducerKeys)) {
    throw new Error('Unexpected type of reducer on ' + keyStack.join('.') + '.');
  }

  return function combination() {
    var states = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
    var action = arguments[1];

    return new Promise(function (resolve, reject) {
      if (!(0, _isPlainObject2.default)(states)) {
        throw new Error('Expected a plain object on state ' + keyStack.join('.') + ' ' + ('but receive type "' + (typeof states === 'undefined' ? 'undefined' : _typeof(states)) + '".') + 'This may happen because of the conflict between two reducer shape.');
      }

      var hasChanged = false;
      var nextStates = {};
      var promises = [];

      if (!(0, _isEqual2.default)(Object.keys(states), finalReducerKeys)) {
        hasChanged = true;
      }

      (0, _forEach2.default)(finalReducerKeys, function (key) {
        var reducer = finalReducers[key];
        var previousState = states[key];

        var p = Promise.all([reducer(previousState, action)]).then(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 1);

          var state = _ref2[0];

          if (state === undefined) {
            var keyStackString = [].concat(_toConsumableArray(keyStack), [key]).join('.');

            throw new Error('Given action "' + action.type + '", ' + ('reducer on ' + keyStackString + ' returned undefined.'));
          }

          nextStates[key] = state;
          hasChanged = hasChanged || state !== previousState;
        });

        promises.push(p);
      });

      Promise.all(promises).then(function () {
        return resolve(hasChanged ? nextStates : states);
      }, function (e) {
        return reject(e);
      });
    });
  };
}