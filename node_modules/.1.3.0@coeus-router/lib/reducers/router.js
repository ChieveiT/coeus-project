'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = router;

// a little hack to sync the popstate event
function syncPopState() {
  return new Promise(function (resolve) {
    var restore = window.onpopstate;

    window.onpopstate = function () {
      window.onpopstate = restore;
      resolve();
    };
  });
}

function router(routes) {
  return function reducer(state, action) {
    if (state === undefined) {
      var target = window.location.pathname + window.location.search;

      if (routes.check(target) === false) {
        throw new Error('[Router] ' + 'A land page rendered in browser should not be 404. ' + 'This should be handled in server.');
      }

      state = {
        status: 'LOADING',
        location: target
      };
    }

    switch (action.type) {
      case 'ROUTE_TO':
        {
          var path = action.path;
          var name = action.name;
          var args = action.args;


          if (name && path) {
            throw new Error('[Router] ' + "'name' and 'path' should not be passed " + 'in action at the same time.');
          }

          var _target = null;
          if (name) {
            _target = routes.linkByName(name, args);
          } else {
            _target = routes.linkByPath(path, args);
          }

          if (routes.check(_target) === false) {
            return _extends({}, state, {
              notFound: path
            });
          }

          history.pushState(null, null, _target);

          return _extends({}, state, {
            status: 'LOADING',
            location: _target
          });
        }
      case 'ROUTE_BACK':
        {
          var popState = syncPopState();

          history.back();

          return popState.then(function () {
            return _extends({}, state, {
              status: 'LOADING',
              location: window.location.pathname + window.location.search
            });
          });
        }
      case 'ROUTE_FORWARD':
        {
          var _popState = syncPopState();

          history.forward();

          return _popState.then(function () {
            return _extends({}, state, {
              status: 'LOADING',
              location: window.location.pathname + window.location.search
            });
          });
        }
      case 'ROUTE_LOADED':
        {
          var _args = action.args;


          return _extends({}, state, {
            status: 'LOADED',
            args: _args
          });
        }
      default:
        return state;
    }
  };
}