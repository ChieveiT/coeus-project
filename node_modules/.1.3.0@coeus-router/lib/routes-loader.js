'use strict';

var _ = require('lodash');
var template = require('./routes-template');

// Because path.join will eat '.' which make
// webpack's require works wrong, so we should
// create our own path.join
function pathJoin() {
  var paths = [];

  _.forEach(arguments, function (v, k) {
    if (k === 0) {
      paths.push(_.trimEnd(v, '/'));
    } else if (k === arguments.length - 1) {
      paths.push(_.trimStart(v, '/'));
    } else {
      paths.push(_.trim(v, '/'));
    }
  });

  return _.filter(paths, function (v) {
    return !_.isEmpty(v);
  }).join('/');
}

module.exports = function (source) {
  this.cacheable && this.cacheable();

  // convert to json so we can traverse routeTree
  var routeTree = JSON.parse(source);

  // for named routes
  var namedRoutes = {};

  (function traverse(node, context) {
    if (_.isString(node.components)) {
      node.components = [node.components];
    }
    if (node.components && !_.isArray(node.components)) {
      throw new Error('Components must be string or array');
    }

    var indexRoute = _.filter(node.children, function (child) {
      return _.isEmpty(child.path);
    });
    if (indexRoute.length > 1) {
      throw new Error('Duplicate index child of a route');
    }

    if (_.isEmpty(node.path) && !_.isEmpty(node.children)) {
      throw new Error('Index route is a leaf that can not has children');
    }

    if (node.name && !_.isEmpty(node.children)) {
      throw new Error('Named route is a leaf that can not has children');
    }

    // create current context to avoid children's contexts
    // affect each other
    var pathTemplate = context.pathTemplate;
    var paramsRegex = Object.assign({}, context.paramsRegex);
    var paramsOptional = Object.assign({}, context.paramsOptional);
    var componentsPath = context.componentsPath;

    // compile path to support regex and params
    if (node.path) {
      var regexMatch = /\<(\??[a-zA-Z_][a-zA-Z_0-9]*):(.*?)\>/g;
      var lastIndex = 0;
      var compiled = '';
      var params = [];

      var match = null;
      while (match = regexMatch.exec(node.path)) {
        var notRegex = node.path.substr(lastIndex, match.index - lastIndex);
        lastIndex = regexMatch.lastIndex;
        compiled += _.escapeRegExp(notRegex);

        var name = match[1];
        var regex = match[2];

        if (paramsRegex[name]) {
          throw new Error('The names of params conflict');
        }

        if (name.substr(0, 1) === '?') {
          name = name.substr(1);

          compiled += '(' + regex + ')?';
          params.push(name);

          paramsRegex[name] = regex;
          paramsOptional[name] = true;
        } else {
          compiled += '(' + regex + ')';
          params.push(name);

          paramsRegex[name] = regex;
          paramsOptional[name] = false;
        }

        pathTemplate += notRegex;
        pathTemplate += '<' + name + '>';
      }

      // deal with tail
      if (lastIndex < node.path.length) {
        var _notRegex = node.path.substr(lastIndex, node.path.length - lastIndex);
        compiled += _.escapeRegExp(_notRegex);

        pathTemplate += _notRegex;
      }

      node._path = compiled;
      node._params = params;
    }

    // for named routes
    if (node.name && _.isEmpty(node.children)) {
      namedRoutes[node.name] = {
        pathTemplate: pathTemplate,
        paramsRegex: paramsRegex,
        paramsOptional: paramsOptional
      };
    }

    // for relative path
    if (!_.isEmpty(node.componentsPath)) {
      componentsPath = node.componentsPath;
    }

    // support relative path
    var components = _.map(node.components, function (v) {
      if (v.substr(0, 1) === ':') {
        return pathJoin(componentsPath, v.substr(1));
      }
      return v;
    });

    // add _components as placeholder, prepare for hack
    if (!_.isEmpty(node.components)) {
      node._components = components;
    }

    // recursive traverse to children
    if (!_.isEmpty(node.children)) {
      _.forEach(node.children, function (n) {
        traverse(n, {
          componentsPath: componentsPath,

          pathTemplate: pathTemplate,
          paramsRegex: paramsRegex,
          paramsOptional: paramsOptional
        });
      });
    }
  })(routeTree, {
    // for relative path
    componentsPath: '',
    // for named routes
    pathTemplate: '',
    paramsRegex: {},
    paramsOptional: {}
  });

  // add match to the root of tree
  routeTree.match = '<match function>';
  // add check to the root of tree
  routeTree.check = '<check function>';
  // add _names and linkByName to the root of tree
  routeTree._names = namedRoutes;
  routeTree.linkByName = '<linkByName function>';
  // add linkByPath to the root of tree
  routeTree.linkByPath = '<linkByPath function>';

  // convert to source so we can hack it as string
  var routeSource = JSON.stringify(routeTree);

  // hack _components to be a require.ensure promise:)
  routeSource = routeSource.replace(/(["'])_components\1\s*?:\s*?(\[.*?\])/g, function () {
    var requireList = JSON.parse(arguments[2]);

    requireList = '[' + _.map(requireList, function (v) {
      return 'require("' + v + '").default || require("' + v + '")';
    }).join(',') + ']';

    var func = template.getFunction(template._components).replace(/require\(\)/g, requireList);

    return '"_components": ' + func;
  });

  // hack match to be a real function:)
  routeSource = routeSource.replace(/(["'])match\1\s*?:\s*?(["'])\<match function\>\2/g, function () {
    var func = template.getFunction(template.match);

    return '"match": ' + func;
  });

  // hack check to be a real function:)
  routeSource = routeSource.replace(/(["'])check\1\s*?:\s*?(["'])\<check function\>\2/g, function () {
    var func = template.getFunction(template.check);

    return '"check": ' + func;
  });

  // hack linkByName to be a real function:)
  routeSource = routeSource.replace(/(["'])linkByName\1\s*?:\s*?(["'])\<linkByName function\>\2/g, function () {
    var func = template.getFunction(template.linkByName);

    return '"linkByName": ' + func;
  });

  // hack linkByPath to be a real function:)
  routeSource = routeSource.replace(/(["'])linkByPath\1\s*?:\s*?(["'])\<linkByPath function\>\2/g, function () {
    var func = template.getFunction(template.linkByPath);

    return '"linkByPath": ' + func;
  });

  return 'module.exports = ' + routeSource;
};